name: Testing Bash

on:
  workflow_dispatch:
    inputs:
      int:
        description: 'Integrations'
        required: true
        default: all
        type: choice
        options:
          - all
          - hr
      environment:
        description: 'Environment to run tests against'
        default: dev
        type: string
        required: true
      object:
        description: 'manual object entry'
        type: string
jobs:
  log-the-inputs:
    runs-on: ubuntu-latest
    env:
       JSON_RESPONSE: ${{ inputs.object }}
    steps:
      - run: |
          echo "Int: $INT"
          echo "Environment: $ENVIRONMENT"
        env:
          INT: ${{ inputs.int }}
          ENVIRONMENT: ${{ inputs.environment }}
      - name: Pretty Print with JQ
        # may want to have jq create the array of commands to run, then use a bash for loop to 
        run: |
          echo '${{ env.JSON_RESPONSE }}' | jq '.'
          echo '${{ env.JSON_RESPONSE }}' | jq '.Schedules[].Name'
          echo '${{ env.JSON_RESPONSE }}' | jq -r ['.Schedules[] | "aws scheduler get-schedule --group-name " + .GroupName + " --name " + .Name']
      - name: Print new command on single line with loop
        run: |
          IFS=""
          for row in $(${{ env.JSON_RESPONSE }} jq -r '.Schedules[] | ("aws scheduler get-schedule --group-name " + .GroupName + " --name " + .Name)'; do
            echo value="$(${row})";
          done
      - name: Read the commands that JQ created
        run: |
          echo 'Commands: ${{ env.JQ_COMMANDS }}'
  
